% Created 2024-05-01 Wed 08:36
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{placeins}
\usepackage{gensymb}
\usepackage{minted}
\author{Christian Johnson \and Aidan Andersen}
\date{\today}
\title{Project 3}
\hypersetup{
 pdfauthor={Christian Johnson \and Aidan Andersen},
 pdftitle={Project 3},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 29.3 (Org mode 9.6.15)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents

\newpage

\section{Given Information}
\label{sec:orgc9cca5b}
\textbf{Problem 1}
\begin{itemize}
\item \(c_1=257261 \pmod{303799}\)
\item \(c_2 = 117466\pmod{289279}\)
\item \(c_3=260584\pmod{410503}\)
\end{itemize}

RSA Moduli:
\begin{itemize}
\item \(n_1=303799\)
\item \(n_2=289729\)
\item \(n_3=410503\)
\end{itemize}

\textbf{Problem 2}
\(p=1234567891\)
\(q=987654323\)
\(e=127\)
\(m=14152019010605\)

\section{Python Code}
\label{sec:org5adb492}

\begin{minted}[,frame=single]{python}
def egcd(a, b):
    if a == 0:
        return b, 0, 1
    else:
        gcd, x, y = egcd(b % a, a)
        return gcd, y - (b // a) * x, x

def mod_inverse(a, m):
    gcd, x, y = egcd(a, m)
    if gcd != 1:
        raise Exception('Modular inverse does not exist')
    else:
        return x % m

def chinese_remainder_theorem(n, a):
    # Calculate N
    N = 1
    for ni in n:
        N *= ni

    # Calculate x
    x = 0
    for ni, ai in zip(n, a):
        Ni = N // ni
        xi = ai * mod_inverse(Ni, ni) * Ni
        x += xi

    return x , N

\end{minted}

\section{Problem 1}
\label{sec:orgf0fe553}
\subsection{Part A}
\label{sec:orgcac06d7}
Find an \(x\) with \(0\le x\le n_{1}n_{2}n_{3}\) and \(x\equiv c_{1}\pmod{n_1}\), \(x\equiv c_{2}\pmod{n_2}\), \(x\equiv c_{1}\pmod{n_2}\).
\(0\le x\le 36132219741486913\)

\begin{minted}[,frame=single]{python}

n=[303799,289729,410503]
c=[257261,117466,260584]
[num, mod]=chinese_remainder_theorem(n,c)
f"x={num%mod}"

\end{minted}

\begin{verbatim}
x=25990919649605545
\end{verbatim}

\subsection{Part B}
\label{sec:org82b75a1}
Show that \(0\le m^{3}\le n_1n_2n_3\)
\(0\le m^3\le 36132219741486913\)

By definition, we know that if \(a\equiv b\pmod{n}\) then \(a^m\equiv b^m\pmod{n}\).
Thus, if \(m^3\equiv c_i\pmod{n_i}\), then \(m\equiv \sqrt[3]{c_i}\pmod{n_i}\).
In RSA, \(m\) should be less than \(n_i\), which means \(m^3< n_i^3\).
This means that \(m\) must be less than \(117466^3\), at the most.
It follows that \(m\) must also be less than \(n_1*n_2*n_3\), since \(36132219741486913>117466^3\)

\subsection{Part C}
\label{sec:orged220af}
Show that \(x=m^3\).
In part A, we found \(x\) such that \(x\equiv c_1\pmod{n_1}\), \(x\equiv c_2\pmod{n_2}\), and \(x\equiv c_3\pmod{n_3}\).
We also know from the given information that \(m^3\equiv c_1\pmod{n_1}\), \(m^3\equiv c_2\pmod{n_2}\), and \(m^3\equiv c_3\pmod{n_3}\).
We know, by definition, that solutions to the chinese remainder theorem are unique, therefore we can conclude that \(x=m^3\).

\subsection{Part D}
\label{sec:org3a0fd3f}
Decode the message \(m\).

\(\\m^3=25990919649605545\\m=\sqrt[3]{25990919649605545}\\\therefore m=296215.114998\)

\section{Problem 2}
\label{sec:orge9ba7a0}

\subsection{Part A}
\label{sec:orgea0f3c9}
Find \(m^e\pmod{p}\) and \(m^e\pmod{q}\).
Use the chinese remainder theorem to combine - \(c\equiv m^e\pmod{pq}\)
\begin{itemize}
\item \(m^e\pmod{p}=14152019010605^{127}\pmod{1234567891}=1156569072\)
\item \(m^e\pmod{q}=14152019010605^{127}\pmod{987654323}=812538893\)
\end{itemize}


Chinese Remainder Theorem - Given \(c_1\equiv a\pmod{m_1}\) and \(c_2\equiv a\pmod{m_2}\), if \(m_1\) and \(m_2\) are relatively prime, then there is some \(c\pmod{m_1*m_2}\) such that \(c\equiv c_1\pmod{m_1}\) and \(c\equiv c_2\pmod{m_2}\).


In our case, we have \(m^e\pmod{p}\) and \(m^e\pmod{q}\).
\(\\gcd(p,q)=1\therefore\text{Relatively Prime}\\\)
From this, we can see that there exists \(c\pmod{p*q}\).
\begin{minted}[,frame=single]{python}
m=[14152019010605**127, 14152019010605**127]
p=[1234567891, 9876534323]
[num, mod]=chinese_remainder_theorem(p,m)
c=num%mod

# Result is c(mod m1*m2)
result=c%(p[0]*p[1])
f"result={result}"

\end{minted}

\begin{verbatim}
result=9868895527985399785
\end{verbatim}

\subsection{Part B}
\label{sec:org7620b4c}


\begin{minted}[,frame=single]{python}

m=[14152019010600**127, 14152019010605**127]
# adjusted me: 14152019010605 to 14152019010600 in me(mod p)
p=[1234567891, 9876534323]
[num, mod]=chinese_remainder_theorem(p,m)
c_new=num%mod

# Result is c(mod m1*m2)
f=c%(p[0]*p[1])
pq=p[0]*p[1]
f"f={f}\npq={pq}"

\end{minted}

\begin{verbatim}
f=9868895527985399785
pq=12193252149535222793
\end{verbatim}


\begin{minted}[,frame=single]{python}

[gcd,_,_] = egcd(result-f,p[0]*p[1])
f"GCD = {gcd}"


\end{minted}

\begin{verbatim}
GCD = 12193252149535222793
\end{verbatim}



\begin{minted}[,frame=single]{python}

# Check if GCD is a factor of PQ
gcd/(p[0]*p[1])

\end{minted}

\begin{verbatim}
1.0
\end{verbatim}


Here, we see that \(gcd(c-f, pq)\) divided by \(pq\) is equal to 1.
This indicates that \(gcd(c-f,pq) == pq\), which makes sense in terms of the gcd operation, since the gcd of two numbers finds their greates common divisor. If the numbers are not already divisible by a common factor, their gcd will be the multiple of the two.
\end{document}
